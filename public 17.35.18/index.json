[{"location":"https://hiboot.hidevops.io/","text":"         About Hiboot is a high performance web and cli application framework with dependency injection\nHiboot is not trying to reinvent everything, it integrates the popular libraries but make them simpler, easier to use. It borrowed some of the Spring features like dependency injection, aspect oriented programming, and auto configuration. You can integrate any other libraries easily by auto configuration with dependency injection support.\nOverview  Web MVC (Model-View-Controller). Auto Configuration, pre-create instance with properties configs for dependency injection. Dependency injection with struct tag name `inject:\u0026ldquo;\u0026rdquo;` or Constructor func.  Features  Apps\n cli - command line application web - web application  Starters\n actuator - health check locale - locale starter logging - customized logging settings jaeger - open tracing starter jaeger jwt - jwt starter grpc - grpc application starter websocket - websocket two-way interactive communication  Tags\n inject - inject generic instance into object default - inject default value into struct object value - inject string value or references / variables into struct string field  Utils\n cmap - concurrent map copier - copy between struct crypto - aes, base64, md5, and rsa encryption / decryption gotest - go test util idgen - twitter snowflake id generator io - file io util mapstruct - convert map to struct replacer - replacing stuct field value with references or environment variables sort - sort slice elements str - string util enhancement util validator - struct field validation   ","title":"Hiboot Cloud Native Application Framework"},{"location":"https://hiboot.hidevops.io/getting-started/","text":" Quick start web application This section will show you how to create and run a simple hiboot web application in 3 steps. Let’s get started!\nGet the source code go get -u hidevops.io/hiboot-web-app-demo cd $GOPATH/src/hidevops.io/hiboot-web-app-demo git log commit 2be5df8e0101b685579f1dd452059d967017148f Author: John Deng \u0026lt;john.deng@qq.com\u0026gt; Date: Sat Nov 3 07:48:46 2018 +0800 Step 3, adding Hiboot controller commit 063c72282edff85db20d4046f5801d7f5fcf4dbb Author: John Deng \u0026lt;john.deng@qq.com\u0026gt; Date: Sat Nov 3 07:45:15 2018 +0800 Step 2, adding some starters commit d9213107f6692bc22c3d79cd445567730b962477 Author: John Deng \u0026lt;john.deng@qq.com\u0026gt; Date: Sat Nov 3 07:38:59 2018 +0800 step 1: Writing the first Hiboot web application - Step 1, writing the first Hiboot web application To write Hiboot application, as we know, the executable commands must always use package main, so we need to create the main package first.\nSee Effective GO to learn more about Go\u0026rsquo;s naming conventions.\ngit reset --hard d9213107f6692bc22c3d79cd445567730b962477 - Step 2, adding some starters Here we are going to add starter actuator and logging.\ngit reset --hard 063c72282edff85db20d4046f5801d7f5fcf4dbb - Step 3, adding Hiboot controller git reset --hard 2be5df8e0101b685579f1dd452059d967017148f Writing the code package main import ( \u0026#34;hidevops.io/hiboot/pkg/app/web\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/starter/actuator\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/starter/logging\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/at\u0026#34; ) // Controller Rest Controller with path / // RESTful Controller, derived from at.RestController. The context mapping of this controller is \u0026#39;/\u0026#39; by default type Controller struct { // at.RestController or at.RestController must be embedded here \tat.RestController } // Get GET / // Get method, the context mapping of this method is \u0026#39;/\u0026#39; by default // the Method name Get means that the http request method is GET func (c *Controller) Get() string { // response \treturn \u0026#34;My first Hiboot web application\u0026#34; } func main() { web.NewApplication(new(Controller)). SetProperty(app.ProfilesInclude, actuator.Profile, logging.Profile). Run() } Run web application dep ensure go run main.go Testing the API by curl curl http://localhost:8080/ Output:\nMy first Hiboot web application Quick start cli application Writing Hiboot cli application is as simple as web application, you can take the advantage of dependency injection introduced by Hiboot.\n// import cli starter and fmt import ( \u0026#34;fmt\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app/cli\u0026#34; ) // define the command type rootCommand struct { // embedding cli.RootCommand \tcli.RootCommand To string } func newRootCommand() *rootCommand { c := new(rootCommand) c.Use = \u0026#34;hello\u0026#34; c.Short = \u0026#34;hello command\u0026#34; c.Long = \u0026#34;run hello command for getting started\u0026#34; c.Example = ` hello -h : help hello -t John : say hello to John ` c.PersistentFlags().StringVarP(\u0026amp;c.To, \u0026#34;to\u0026#34;, \u0026#34;t\u0026#34;, \u0026#34;world\u0026#34;, \u0026#34;e.g. --to=world or -t world\u0026#34;) return c } // Run run the command func (c *rootCommand) Run(args []string) error { fmt.Printf(\u0026#34;Hello, %v\\n\u0026#34;, c.To) return nil } // main function func main() { // create new cli application and run it \tcli.NewApplication(newRootCommand). SetProperty(app.PropertyBannerDisabled, true). Run() } Run cli application dep ensure go run main.goHello, world Build the cli application and run go build Let\u0026rsquo;s get help\n./hello --helprun hello command for getting started Usage: hello [flags] Flags: -h, --help help for hello -t, --to string e.g. --to=world or -t world (default \u0026#34;world\u0026#34;) Greeting to Hiboot\n./hello --to HibootHello, Hiboot","title":"Getting started"},{"location":"https://hiboot.hidevops.io/web-app/","text":" Features  *Web MVC (Model-View-Controller). Auto Configuration, pre-created instance with properties configs for dependency injection. Dependency injection with the struct tag `inject:\u0026ldquo;\u0026rdquo;` or the constructor.   Introduction to Hiboot MVC Hiboot prefers to hide the business-independent code, so that the developers will concentrate the business logic.\nunlike most of the Go web frameworks, Hiboot does not need to setup routes. Hiboot use reflection to construct the routes.\nProject structure . ├── config │ ├── application-gorm.yml │ ├── application-local.yml │ ├── application.yml │ ├── i18n │ │ ├── en-US.ini │ │ └── zh-CN.ini │ ├── keygen.sh │ └── ssl │ ├── app.rsa │ └── app.rsa.pub ├── main.go ├── main_test.go ├── controller │ ├── user.go │ └── user_test.go ├── entity │ ├── user.go │ └── user_test.go └── service ├── user.go └── user_test.go Hiboot application include source code and config\nApplication properties Hiboot lets you externalize your configuration so that you can work with the same application code in different environments.\nProperty values can be injected directly into the struct using the `value:\u0026ldquo;\u0026rdquo;` tag.\nTo provide a concrete example, suppose you develop a struct that uses a app.name property, as shown in the following example：\ntype MyService struct { AppName string `value:\u0026#34;${app.name}\u0026#34;` } Common application properties Various properties can be specified inside your application.yml file. Hiboot loads properties form application.yml in config folder of working directory.\nconfig/application.yml app:project:examplesname:gorm-demoprofiles:include:-actuator-locale-logging-gormlogging:level:info application.yml field description    Field Description Options Example     app.project project name any string examples   app.name application name any string gorm-demo   app.profiles.active application active profile local,dev,test,staging,prod dev   app.profiles.include we use this field as starter switcher，⚠️ if the starter is imported in your source file but it\u0026rsquo;s not included here, the starter will not be initialized pakcage name of the starter actuator, locale, logging, gorm   logging.level set the logging level debug,info,warn,error,fatal info    Profile-specific properties In addition to application.yml file, profile-specific properties can also be defined by using the following naming convention: application-${profile}.yml, active profiles can be set in application.yml.\nProfile-specific properties are loaded from the same locations as standard application.yml, with profile-specific files always overriding the non-specific ones. application-${app.profiles.active}.yml is always be the highest priority.\nconfig/application-local.yml server:port:8081logging:level:debug application-local.yml field description    Field Description Options Example     server.port service port that the application is listening on, it will overwrite the server.port in application.yml any number 8081   logging.level set logging level debug,info,warn,error,fatal info    config/application-gorm.yml gorm:type:mysqlhost:mysql-${app.profiles.active:dev}port:3306database:${app.name:test}username:demopassword:fafUJCsVXf2Thj0d4n6UqNdX2PfI08fMyaNlrZhbJVVkghnZ+Zc/WCdITXflJpHZjYH5+LbLviy/6j9etPNwtdyAOXiqKI62itC6nDgp0Xlzu0qX8MwMIIAosUwaYpnflg23hRZnueKrq6SrEpkx4X+LWluDgHb2O5VfGGvHliE=charset:utf8parseTime:trueloc:Asia/Shanghaiconfig:decrypt:true application-gorm.yml field description    Field Description Options Example     gorm.type database type mysql,postgres,sqlite3,mssql mysql   gorm.host database host, can be IP address or DNS name, mysql-${app.profiles.active} if environment variable APP_PROFILES_ACTIVE is set to local，then gorm.host will be mysql-local） mysql-${app.profiles.active}    gorm.port database port any port 3306   gorm.database database name string or variable ${app.name:test}   gorm.username username for databse connection valid username in string dbuser   gorm.password password for database connnection, if gorm.config.decrypt is true，then it will be the password that encrypted by crypto string fafUJ \u0026hellip; O5VfGGvHliE=   gorm.charset character set utf8,ascii utf8   gorm.parseTime parse time or not true,false true   gorm.loc timezone see world timezone Asia/Shanghai   gorm.config.decrypt decrypt or not true,false true    Writing the Code To write Hiboot application, as we know, the executable commands must always use package main, so we need to create the main package first.\nSee Effective GO to learn more about Go\u0026rsquo;s naming conventions.\nmain.go There are two parts inside the main package：imports and the entrance of the web application。\n In order to decouple each packages, hiboot use registeration, auto configuration and dependency injection, as we need to import some packages solely for their side effects, for exampole: _ \u0026quot;hidevops.io/hiboot-data/examples/gorm/controller\u0026quot;, if you used hiboot starter you may need import them in this way as well：_ \u0026quot;hidevops.io/hiboot/pkg/starter/actuator\u0026quot;, _ \u0026quot;hidevops.io/hiboot/pkg/starter/locale\u0026quot;, _ \u0026quot;hidevops.io/hiboot/pkg/starter/logging\u0026quot;\n the function main is extremely simple, that is web.NewApplication().Run(), the package web is imported from hidevops.io/hiboot/pkg/app/web\npackage main import ( _ \u0026#34;hidevops.io/hiboot-data/examples/gorm/controller\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app/web\u0026#34; _ \u0026#34;hidevops.io/hiboot/pkg/starter/actuator\u0026#34; _ \u0026#34;hidevops.io/hiboot/pkg/starter/locale\u0026#34; _ \u0026#34;hidevops.io/hiboot/pkg/starter/logging\u0026#34; ) func main() { web.NewApplication().Run() }   Alternatively, you can set property app.ProfilesInclude in main function. In this approach, you don\u0026rsquo;t have to import starter packages solely for their side effects.\n package main import ( \u0026#34;hidevops.io/hiboot/pkg/app/web\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/starter/actuator\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/starter/logging\u0026#34; ) func main() { web.NewApplication(). SetProperty(app.ProfilesInclude, actuator.Profile, logging.Profile). Run() } Controller - controller/user.go Now lets see how does the Hiboot controller works, the controller userController is embedded a struct at.RestController, it tells Hiboot that this is a web controller。\nnewUserController is the constructor of struct userController, the dependency userService service.UserService is injecting through the argument of the constructor during the initialization of newUserController。\nFor the simplicity purpose, Hiboot does not need to config route, the method name is the route.\nHere is the list of the HTTP methods,\n   Method Description Options Example     \u0008Get GET Get or GetById which in camel case func (c *userController) GetById(id unit64)   Post POST Post PostUser which in camel case func (c *userController) Post(request *userRequest)   Put PUT Put or PutUser which in camel case func (c *userController) Post(request *userRequest)   Delete DELETE Delete DeleteById which in camel case func (c *userController) DeleteById(id unit64)    ⚠️ Note that the constructor newUserController of the controller must be registered in the func init().\npackage controller import ( \u0026#34;hidevops.io/hiboot-data/examples/gorm/entity\u0026#34; \u0026#34;hidevops.io/hiboot-data/examples/gorm/service\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app/web\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/model\u0026#34; \u0026#34;net/http\u0026#34; ) // RestController type userController struct { at.RestController userService service.UserService } func init() { app.Register(newUserController) } // newUserController inject userService automatically func newUserController(userService service.UserService) *userController { return \u0026amp;userController{ userService: userService, } } // Post POST /user func (c *userController) Post(request *entity.User) (model.Response, error) { err := c.userService.AddUser(request) response := new(model.BaseResponse) response.SetData(request) return response, err } // GetById GET /id/{id} func (c *userController) GetById(id uint64) (response model.Response, err error) { user, err := c.userService.GetUser(id) response = new(model.BaseResponse) if err != nil { response.SetCode(http.StatusNotFound) } else { response.SetData(user) } return } // GetById GET /id/{id} func (c *userController) GetAll() (response model.Response, err error) { users, err := c.userService.GetAll() response = new(model.BaseResponse) response.SetData(users) return } // DeleteById DELETE /id/{id} func (c *userController) DeleteById(id uint64) (response model.Response, err error) { err = c.userService.DeleteUser(id) response = new(model.BaseResponse) return } entity/user.go User entity is the business model.\ntype User struct { model.RequestBody Id uint64 `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34; validate:\u0026#34;required\u0026#34;` Username string `json:\u0026#34;username\u0026#34; validate:\u0026#34;required\u0026#34;` Password string `json:\u0026#34;password\u0026#34; validate:\u0026#34;required\u0026#34;` Email string `json:\u0026#34;email\u0026#34; validate:\u0026#34;required,email\u0026#34;` Age uint `json:\u0026#34;age\u0026#34; validate:\u0026#34;gte=0,lte=130\u0026#34;` Gender uint `json:\u0026#34;gender\u0026#34; validate:\u0026#34;gte=0,lte=2\u0026#34;` } // Here we specify the table name as user instead of users by default. func (u *User) TableName() string { return \u0026#34;user\u0026#34; } Model - service/user.go Service implements the business logic. We declared an interface UserService，which includes method AddUser, GetUser, GetAll, and DeleteUser, userServiceImpl is the implementation of UserService。\nBy importing hidevops.io/hiboot-data/starter/gorm，the instance of repository gorm.Repository will be injectable, it will be injected to userServiceImpl through the constructor newUserService.\n⚠️ Note that the constructor newUserService must be registered in the func init().\npackage service import ( \u0026#34;errors\u0026#34; \u0026#34;hidevops.io/hiboot-data/examples/gorm/entity\u0026#34; \u0026#34;hidevops.io/hiboot-data/starter/gorm\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/utils/idgen\u0026#34; ) type UserService interface { AddUser(user *entity.User) (err error) GetUser(id uint64) (user *entity.User, err error) GetAll() (user *[]entity.User, err error) DeleteUser(id uint64) (err error) } type userServiceImpl struct { // add UserService, it means that the instance of UserServiceImpl can be found by UserService \tUserService repository gorm.Repository } func init() { // register UserServiceImpl \tapp.Register(newUserService) } // will inject BoltRepository that configured in hidevops.io/hiboot/pkg/starter/data/bolt func newUserService(repository gorm.Repository) UserService { repository.AutoMigrate(\u0026amp;entity.User{}) return \u0026amp;userServiceImpl{ repository: repository, } } func (s *userServiceImpl) AddUser(user *entity.User) (err error) { if user == nil { return errors.New(\u0026#34;user is not allowed nil\u0026#34;) } if user.Id == 0 { user.Id, _ = idgen.Next() } err = s.repository.Create(user).Error() return } func (s *userServiceImpl) GetUser(id uint64) (user *entity.User, err error) { user = \u0026amp;entity.User{} err = s.repository.Where(\u0026#34;id = ?\u0026#34;, id).First(user).Error() return } func (s *userServiceImpl) GetAll() (users *[]entity.User, err error) { users = \u0026amp;[]entity.User{} err = s.repository.Find(users).Error() return } func (s *userServiceImpl) DeleteUser(id uint64) (err error) { err = s.repository.Where(\u0026#34;id = ?\u0026#34;, id).Delete(entity.User{}).Error() return } Run the sample code go run main.go Output:\n______ ____________ _____ ___ / / /__(_)__ /_______________ /_ __ /_/ /__ /__ __ \\  __ \\  __ \\  __/ _ __ / _ / _ /_/ / /_/ / /_/ / /_ Hiboot Application Framework /_/ /_/ /_/ /_.___/\\____/\\____/\\__/ https://hidevops.io/hiboot [INFO] 2018/10/23 23:37 Starting Hiboot web application gorm-demo on localhost with PID 28423 [INFO] 2018/10/23 23:37 Working directory: /Users/johnd/.gvm/pkgsets/go1.10/hidevops/src/hidevops.io/hiboot-data/examples/gorm [INFO] 2018/10/23 23:37 The following profiles are active: local, [actuator locale logging gorm] [INFO] 2018/10/23 23:37 Auto configure gorm starter [INFO] 2018/10/23 23:37 Auto configure locale starter [INFO] 2018/10/23 23:37 Auto configure logging starter [INFO] 2018/10/23 23:37 The dependency graph resolved successfully [INFO] 2018/10/23 23:37 connected to dataSource demo@mysql-local:3306/gorm_demo [DBUG] 2018/10/23 23:36 GET: /health -\u0026gt; github.com/hidevops\tio/hiboot-data/vendor/hidevops.io/hiboot/pkg/starter/actuator/controller/healthController.Get() and 2 more [DBUG] 2018/10/23 23:36 DELETE: /user/id/{id} -\u0026gt; hidevops.io/hiboot-data/examples/gorm/controller/userController.DeleteById() and 2 more [DBUG] 2018/10/23 23:36 GET: /user/id/{id} -\u0026gt; hidevops.io/hiboot-data/examples/gorm/controller/userController.GetById() and 2 more [DBUG] 2018/10/23 23:36 GET: /user/all -\u0026gt; hidevops.io/hiboot-data/examples/gorm/controller/userController.GetAll() and 2 more [DBUG] 2018/10/23 23:36 POST: /user -\u0026gt; hidevops.io/hiboot-data/examples/gorm/controller/userController.Post() and 2 more Now listening on: http://localhost:8080 Application started. Press CMD+C to shut down. Make a request Let\u0026rsquo;s make a request on the RESTful API GET /user/all\nhttp GET localhost:8080/user/allHTTP/1.1 200 OK Content-Length: 307 Content-Type: application/json; charset=UTF-8 Date: Tue, 23 Oct 2018 15:38:41 GMT Set-Cookie: app.language=; Path=/; Expires=Tue, 23 Oct 2018 17:38:41 GMT; Max-Age=7200; HttpOnly { \u0026#34;code\u0026#34;: 200, \u0026#34;data\u0026#34;: [ { \u0026#34;age\u0026#34;: 18, \u0026#34;email\u0026#34;: \u0026#34;john.doe@gmail.com\u0026#34;, \u0026#34;gender\u0026#34;: 0, \u0026#34;id\u0026#34;: 209536579658580081, \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;poi321\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;johnd\u0026#34; }, { \u0026#34;age\u0026#34;: 25, \u0026#34;email\u0026#34;: \u0026#34;mike.phil@gmail.com\u0026#34;, \u0026#34;gender\u0026#34;: 0, \u0026#34;id\u0026#34;: 209536656246571121, \u0026#34;name\u0026#34;: \u0026#34;Mike Phil\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;iutg039\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;mikep\u0026#34; } ], \u0026#34;message\u0026#34;: \u0026#34;Success\u0026#34; } Unit test As I always say, Hiboot is built for production ready, we care about the quality so much, here is the realtime code coverage . So how do we do the unit testing?\nFirst, let\u0026rsquo;s see the unit test for main.go\nmian_test.go As shown below, the unit test for func main，\u0008we have go main() inside the test case TestRunMain just for the sake of main func testing。\npackage main import ( \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; ) func TestRunMain(t *testing.T) { go main() time.Sleep(200 * time.Millisecond) } Mock up the testing - controller/user_test.go We want to test the userController, but the userController depends on userSerivce which will connect to the real database through gorm repository. In order to do so, we must mock the userService.\nWe use Mockery to generate the some of the test code, Mockery is a tool that automatically generates mock implementations of interfaces UserService.\nFirst, install mockery,\ngo get github.com/vektra/mockery/.../ Then, generate mocks for the interface\n# go to the directory where the UserService is. cd $GOPATH/src/hidevops.io/hiboot-data/examples/gorm/service # generate mocks for the interface UserService mockery -name UserService After that, you will see mocks/UserService is generated under $GOPATH/src/hidevops.io/hiboot-data/examples/gorm/service.\n// Code generated by mockery v1.0.0. DO NOT EDIT.  package mocks import entity \u0026#34;hidevops.io/hiboot-data/examples/gorm/entity\u0026#34; import mock \u0026#34;github.com/stretchr/testify/mock\u0026#34; // UserService is an autogenerated mock type for the UserService type type UserService struct { mock.Mock } // AddUser provides a mock function with given fields: user func (_m *UserService) AddUser(user *entity.User) error { ret := _m.Called(user) var r0 error if rf, ok := ret.Get(0).(func(*entity.User) error); ok { r0 = rf(user) } else { r0 = ret.Error(0) } return r0 } // DeleteUser provides a mock function with given fields: id func (_m *UserService) DeleteUser(id uint64) error { ret := _m.Called(id) var r0 error if rf, ok := ret.Get(0).(func(uint64) error); ok { r0 = rf(id) } else { r0 = ret.Error(0) } return r0 } // GetAll provides a mock function with given fields: func (_m *UserService) GetAll() (*[]entity.User, error) { ret := _m.Called() var r0 *[]entity.User if rf, ok := ret.Get(0).(func() *[]entity.User); ok { r0 = rf() } else { if ret.Get(0) != nil { r0 = ret.Get(0).(*[]entity.User) } } var r1 error if rf, ok := ret.Get(1).(func() error); ok { r1 = rf() } else { r1 = ret.Error(1) } return r0, r1 } // GetUser provides a mock function with given fields: id func (_m *UserService) GetUser(id uint64) (*entity.User, error) { ret := _m.Called(id) var r0 *entity.User if rf, ok := ret.Get(0).(func(uint64) *entity.User); ok { r0 = rf(id) } else { if ret.Get(0) != nil { r0 = ret.Get(0).(*entity.User) } } var r1 error if rf, ok := ret.Get(1).(func(uint64) error); ok { r1 = rf(id) } else { r1 = ret.Error(1) } return r0, r1 } Writing the unit test cases Below are the unit test cases, we tested POST, GET, DELETE method to user controller with the mock interface mocks.UserService.\npackage controller import ( \u0026#34;hidevops.io/hiboot-data/examples/gorm/entity\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app/web\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/log\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/utils/idgen\u0026#34; \u0026#34;github.com/stretchr/testify/assert\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;hidevops.io/hiboot-data/examples/gorm/service/mocks\u0026#34; \u0026#34;errors\u0026#34; ) func init() { log.SetLevel(log.DebugLevel) } func TestCrdRequest(t *testing.T) { mockUserService := new(mocks.UserService) userController := newUserController(mockUserService) testApp := web.RunTestApplication(t, userController) id, err := idgen.Next() assert.Equal(t, nil, err) testUser := \u0026amp;entity.User{ Id: id, Name: \u0026#34;Bill Gates\u0026#34;, Username: \u0026#34;billg\u0026#34;, Password: \u0026#34;3948tdaD\u0026#34;, Email: \u0026#34;bill.gates@microsoft.com\u0026#34;, Age: 60, Gender: 1, } // first, call mocks.UserService.AddUser \tmockUserService.On(\u0026#34;AddUser\u0026#34;, testUser).Return(nil) // then run the test that will call UserService.AddUser \tt.Run(\u0026#34;should add user with POST request\u0026#34;, func(t *testing.T) { // First, let\u0026#39;s Post User \ttestApp.Post(\u0026#34;/user\u0026#34;). WithJSON(testUser). Expect().Status(http.StatusOK) }) mockUserService.On(\u0026#34;GetUser\u0026#34;, id).Return(testUser, nil) t.Run(\u0026#34;should get user with GET request\u0026#34;, func(t *testing.T) { // Then Get User \t// e.g. GET /user/id/123456 \ttestApp.Get(\u0026#34;/user/id/{id}\u0026#34;). WithPath(\u0026#34;id\u0026#34;, id). Expect().Status(http.StatusOK) }) mockUserService.On(\u0026#34;GetAll\u0026#34;).Return(\u0026amp;[]entity.User{*testUser}, nil) t.Run(\u0026#34;should get user with GET request\u0026#34;, func(t *testing.T) { // Then Get User \t// e.g. GET /user/id/123456 \ttestApp.Get(\u0026#34;/user/all\u0026#34;). Expect().Status(http.StatusOK) }) // assert that the expectations were met \tmockUserService.AssertExpectations(t) unknownId, err := idgen.Next() assert.Equal(t, nil, err) mockUserService.On(\u0026#34;GetUser\u0026#34;, unknownId).Return((*entity.User)(nil), errors.New(\u0026#34;not found\u0026#34;)) t.Run(\u0026#34;should return 404 if trying to find a record that does not exist\u0026#34;, func(t *testing.T) { // Then Get User \ttestApp.Get(\u0026#34;/user/id/{id}\u0026#34;). WithPath(\u0026#34;id\u0026#34;, unknownId). Expect().Status(http.StatusNotFound) }) // assert that the expectations were met \tmockUserService.AssertExpectations(t) mockUserService.On(\u0026#34;DeleteUser\u0026#34;, id).Return(nil) t.Run(\u0026#34;should delete the record with DELETE request\u0026#34;, func(t *testing.T) { // Finally Delete User \ttestApp.Delete(\u0026#34;/user/id/{id}\u0026#34;). WithPath(\u0026#34;id\u0026#34;, id). Expect().Status(http.StatusOK) }) } Finally, Let run above unit tests, the test result is positive. ","title":"Web Application"},{"location":"https://hiboot.hidevops.io/cli-app/","text":" About Hiboot cli application Hiboot cli application is built based on top of cobra with Hiboot dependency injection and auto configuration.\nFeatures  Dependency Injection Sub command handler  Cli application structure . ├── cmd │ ├── bar.go │ ├── foo.go │ ├── root.go │ ├── root_test.go │ └── second.go ├── config │ ├── autoconfigure.go │ └── autoconfigure_test.go ├── main.go ├── main_test.go └── model ├── foo.go └── foo_test.go Just like web application, Hiboot cli application is designed to be simpler and easier.\npackage main import ( \u0026#34;hidevops.io/hiboot/examples/cli/advanced/cmd\u0026#34; \u0026#34;hidevops.io/hiboot/examples/cli/advanced/config\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app/cli\u0026#34; ) func main() { // create new cli application and run it \tcli.NewApplication(cmd.NewRootCommand). SetProperty(app.ProfilesInclude, config.Profile). Run() } Root Command package cmd import ( \u0026#34;hidevops.io/hiboot/pkg/app/cli\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/log\u0026#34; ) // HelloCommand is the root command type HelloCommand struct { cli.RootCommand profile string timeout int } // HelloCommand the root command func NewHelloCommand(second *secondCommand) *HelloCommand { c := new(RootCommand) c.Use = \u0026#34;hello\u0026#34; c.Short = \u0026#34;hello command\u0026#34; c.Long = \u0026#34;Run hello command\u0026#34; c.ValidArgs = []string{\u0026#34;baz\u0026#34;} pf := c.PersistentFlags() pf.StringVarP(\u0026amp;c.profile, \u0026#34;profile\u0026#34;, \u0026#34;p\u0026#34;, \u0026#34;dev\u0026#34;, \u0026#34;e.g. --profile=test\u0026#34;) pf.IntVarP(\u0026amp;c.timeout, \u0026#34;timeout\u0026#34;, \u0026#34;t\u0026#34;, 1, \u0026#34;e.g. --timeout=1\u0026#34;) c.Add(second) return c } // Run root command handler func (c *HelloCommand) Run(args []string) error { log.Infof(\u0026#34;handle first command: profile=%v, timeout=%v\u0026#34;, c.profile, c.timeout) return nil } Sub Command package cmd import ( \u0026#34;hidevops.io/hiboot/pkg/app\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app/cli\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/log\u0026#34; ) type secondCommand struct { cli.SubCommand } func init() { app.Register(newSecondCommand) } func newSecondCommand(foo *fooCommand, bar *barCommand) *secondCommand { c := new(secondCommand) c.Use = \u0026#34;second\u0026#34; c.Short = \u0026#34;second command\u0026#34; c.Long = \u0026#34;Run second command\u0026#34; c.Add(foo, bar) return c } func (c *secondCommand) Run(args []string) error { log.Info(\u0026#34;handle second command\u0026#34;) return nil }","title":"Cli Applications"},{"location":"https://hiboot.hidevops.io/inversion-of-control/","text":" Intruduction to IoC The main goal of Inversion of control and Dependency Injection is to remove dependencies of an application. This makes the system more decoupled and maintainable.\nDependency injection is a concept valid for any programming language. The general concept behind dependency injection is called Inversion of Control. According to this concept a struct should not configure its dependencies statically but should be configured from the outside.\nDependency Injection design pattern allows us to remove the hard-coded dependencies and make our application loosely coupled, extendable and maintainable.\nA Go struct has a dependency on another struct, if it uses an instance of this struct. We call this a struct dependency. For example, a struct which accesses a user controller has a dependency on user service struct.\nIdeally Go struct should be as independent as possible from other Go struct. This increases the possibility of reusing these struct and to be able to test them independently from other struct.\nThe following example shows a struct which has no hard dependencies.\nDependency Injection One of the most significant feature of Hiboot is Dependency Injection. Hiboot implements JSR-330 standard.\nDependency Injection provides objects that an object needs. So rather than the dependencies construct themselves they are injected by some external means. For instance let’s say we have the following below struct userService who uses a gorm.Repository interface to query record from database. So rather than connect the database and creating an instance gorm.Repository from within the constructor, we can inject the same by importing via a constructor as shown in the below code snippet.\ntype userService struct { repository gorm.Repository } func newUserService(repository gorm.Repository) *userService { return \u0026amp;userService{ repository: repository, } } Constructor Injection Although Field Injection is pretty convenient, but the Constructor Injection is the first-class citizen, we usually advise people to use constructor injection as it has below advantages,\n It\u0026rsquo;s testable, easy to implement unit test. Syntax validation, with syntax validation on most of the IDEs to avoid typo. No need to use a dedicated mechanism to ensure required properties are set.\npackage main import ( \u0026#34;hidevops.io/hiboot/pkg/app/web\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/model\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/starter/jwt\u0026#34; \u0026#34;time\u0026#34; ) // This example shows that jwtToken is injected through the constructor, // once you imported \u0026#34;hidevops.io/hiboot/pkg/starter/jwt\u0026#34;, // jwtToken jwt.Token will be injectable. func main() { // the web application entry \tweb.NewApplication().Run() } // PATH: /login type loginController struct { at.RestController token jwt.Token } type userRequest struct { // embedded field model.RequestBody mark that userRequest is request body \tmodel.RequestBody Username string `json:\u0026#34;username\u0026#34; validate:\u0026#34;required\u0026#34;` Password string `json:\u0026#34;password\u0026#34; validate:\u0026#34;required\u0026#34;` } func init() { // Register Rest Controller through constructor newLoginController \tapp.Register(newLoginController) } // newLoginController inject jwtToken through the argument jwtToken jwt.Token on constructor // the dependency jwtToken is auto configured in jwt starter, see https://hidevops.io/hiboot/pkg/starter/jwt func newLoginController(token jwt.Token) *loginController { return \u0026amp;loginController{ token: token, } } // Post / // The first word of method is the http method POST, the rest is the context mapping func (c *loginController) Post(request *userRequest) (response model.Response, err error) { jwtToken, _ := c.token.Generate(jwt.Map{ \u0026#34;username\u0026#34;: request.Username, \u0026#34;password\u0026#34;: request.Password, }, 30, time.Minute) response = new(model.BaseResponse) response.SetData(jwtToken) return }  Field Injection In Hiboot the injection into fields is triggered by `inject:\u0026ldquo;\u0026rdquo;` struct tag. when inject tag is present on a field, Hiboot tries to resolve the object to inject by the type of the field. If several implementations of the same service interface are available, you have to disambiguate which implementation you want to be injected. This can be done by naming the field to specific implementation.\ntype userController struct { at.RestController BasicAuthenticationService AuthenticationService\t`inject:\u0026#34;\u0026#34;` Oauth2AuthenticationService AuthenticationService\t`inject:\u0026#34;\u0026#34;` } func newUserController() { return \u0026amp;userController{} } func init() { app.Register(newUserController) } Method Injection Method Injection one of the most significant features of Hiboot. Below is the source code of Hiboot starter jwt. Middleware() is depends on Token, Hiboot will inject the instance of Token through the argument of the method. For more details, please see Hiboot starter\n// Package jwt provides the hiboot starter for injectable jwt dependency package jwt import ( \u0026#34;github.com/dgrijalva/jwt-go\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app\u0026#34; mw \u0026#34;github.com/iris-contrib/middleware/jwt\u0026#34; ) type configuration struct { app.Configuration Properties Properties `mapstructure:\u0026#34;jwt\u0026#34;` middleware *Middleware token Token } func init() { app.Register(newConfiguration) } func newConfiguration() *configuration { return \u0026amp;configuration{} } // Middleware is the jwt handler func (c *configuration) Middleware(jwtToken Token) *Middleware { return NewJwtMiddleware(mw.Config{ ValidationKeyGetter: func(token *jwt.Token) (interface{}, error) { //log.Debug(token) \treturn jwtToken.VerifyKey(), nil }, // When set, the middleware verifies that tokens are signed with the specific signing algorithm \t// If the signing method is not constant the ValidationKeyGetter callback can be used to implement additional checks \t// Important to avoid security issues described here: https://auth0.com/blog/2015/03/31/critical-vulnerabilities-in-json-web-token-libraries/ \tSigningMethod: jwt.SigningMethodRS256, }) } // Token func (c *configuration) Token() Token { t := new(jwtToken) t.Initialize(\u0026amp;c.Properties) return t }","title":"Inversion of Control"},{"location":"https://hiboot.hidevops.io/auto-configure/","text":" Auto-configured Starter Hiboot auto-configuration attempts to automatically configure your Hiboot application based on the pkg dependencies that you have added. For example, if bolt is imported in you main.go, and you have not manually configured any database connection, then Hiboot auto-configures an database bolt for any service to inject.\nYou need to opt-in to auto-configuration by embedding app.Configuration in your configuration and calling the app.Register() function inside the init() function of your configuration pkg.\nFor more details, see https://godoc.org/hidevops.io/hiboot/pkg/starter\nCreating Your Own Starter A full Hiboot starter for a library may contain the following structs: autoconfigure - object that handle the auto-configuration code. properties - object that contains properties which will be injected configurable default values or user specified values If you work in a company that develops shared go packages, or if you work on an open-source or commercial project, you might want to develop your own auto-configured starter. starter can be implemented in external packages and can be imported by any go applications.\nUnderstanding Auto-configured Starter\nUnder the hood, auto-configuration is implemented with standard struct. Additional embedded field app.Configuration. AutoConfiguration used to constrain when the auto-configuration should apply. Usually, auto-configuration struct use after:\u0026quot;fooConfiguration\u0026quot; or missing:\u0026quot;fooConfiguration\u0026quot; tags. This ensures that auto-configuration applies only when relevant configuration are found and when you have not declared your own configuration.\nCode Example This example shows the guide to make customized auto configuration for more details, see https://hidevops.io/hiboot-data/blob/master/starter/bolt/autoconfigure.go\npackage bolt import ( \u0026#34;hidevops.io/hiboot/pkg/app\u0026#34; \u0026#34;os\u0026#34; ) // properties type properties struct { Database string `json:\u0026#34;database\u0026#34; default:\u0026#34;hiboot.db\u0026#34;` Mode os.FileMode `json:\u0026#34;mode\u0026#34; default:\u0026#34;0600\u0026#34;` Timeout int64 `json:\u0026#34;timeout\u0026#34; default:\u0026#34;2\u0026#34;` } // declare boltConfiguration type boltConfiguration struct { app.Configuration // the properties member name must be Bolt if the mapstructure is bolt, \t// so that the reference can be parsed \tBoltProperties properties `mapstructure:\u0026#34;bolt\u0026#34;` } // BoltRepository type BoltRepository struct { } func init() { // register newBoltConfiguration as AutoConfiguration \tapp.Register(newBoltConfiguration) } // boltConfiguration constructor func newBoltConfiguration() *boltConfiguration { return \u0026amp;boltConfiguration{} } func (c *boltConfiguration) BoltRepository() *BoltRepository { repo := \u0026amp;BoltRepository{} // config repo according to c.BoltProperties  return repo }","title":"Auto Configuration"},{"location":"https://hiboot.hidevops.io/tags/auto-configuration/","text":"","title":"auto-configuration"},{"location":"https://hiboot.hidevops.io/tags/go/","text":"","title":"go"},{"location":"https://hiboot.hidevops.io/tags/starter/","text":"","title":"starter"},{"location":"https://hiboot.hidevops.io/tags/","text":"","title":"Tags"},{"location":"https://hiboot.hidevops.io/tags/application/","text":"","title":"application"},{"location":"https://hiboot.hidevops.io/tags/cli/","text":"","title":"cli"},{"location":"https://hiboot.hidevops.io/about/","text":"Hugo is a static site engine written in Go.\nIt makes use of a variety of open source projects including:\n Cobra Viper J Walter Weatherman Cast  Learn more and contribute on GitHub.\n","title":"About Hugo"},{"location":"https://hiboot.hidevops.io/tags/index/","text":"","title":"Index"},{"location":"https://hiboot.hidevops.io/search/","text":"","title":"Search Results"},{"location":"https://hiboot.hidevops.io/topics/","text":"","title":"Topics"}]