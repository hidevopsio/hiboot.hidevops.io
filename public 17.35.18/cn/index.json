[{"location":"https://hiboot.hidevops.io/cn/","text":" 关于         Hiboot 是一款用Go语言实现的高性能网络及命令行应用框架。Hiboot提供了Web MVC框架，支持控制反转（依赖注入），拦截器，依赖包自动配置（类似Spring Boot的Starter）。\nHiboot并不打算重复造轮子，故使用了自动配置的机制，很轻松的集成\u0008任何第三方依赖包，并使得其更方便使用，例如数据库连接，不需要在业务代码中\u0008配置及创建数据库连接，你只要依赖hiboot-data/starter/gorm即可注入数据库\u0008连接实例，直接实现数据库查询。\n总览  MVC架构 (Model-View-Controller). 自动配置, 事先配置好的依赖包可以被注入到任何你指定的构造函数参数中或者结构体变量 依赖注入， 使用标签 `inject:\u0026ldquo;\u0026rdquo;` 或者构造函数来实现.  功能列表  Apps - 应用  cli - 命令行应用 web - 网络应用  Starters - 自动配置  actuator - 健康检测 locale - 国际化 logging - 日志 jaeger - 分布式链路追踪 jwt - JWT 令牌 grpc - 服务间通讯gRPC websocket - websocket 服务端与客户端实时通信  Tags - 标签  inject - 注入依赖 default - 注入默认值 value - 注入常量，环境变量或引用值  Utils - 工具  cmap - 支持并发的map copier - 复制struct工具 crypto - aes, base64, md5, and rsa 加／解密工具 gotest - go test 工具 idgen - twitter snowflake 唯一 id 生成器 io - 文件操作工具 mapstruct - 转换map 到 struct replacer - 替换struct中的值为引用或环境变量 sort - 切片排序 str - 字符串处理工具 validator - 参数校验   ","title":"Hiboot云原生应用框架"},{"location":"https://hiboot.hidevops.io/cn/getting-started/","text":" 前提 我们假设你以及安装了Go语言的开发环境。当然，如果你没安装，则按照GO语言环境搭建详解来安装。\n网络应用快速入门 我们将在本章节演示如何快速入门Hiboot网络应用，即通过简单三个步骤来创建一个最简单的Hiboot应用。闲话不多说，我们开始吧！\n获取代码 首先到github拉取演示代码，在命令行终端运行以下命令即可：\ngo get -u hidevops.io/hiboot-web-app-demo cd $GOPATH/src/hidevops.io/hiboot-web-app-demo 查看历史记录\ngit log 结果如下：\ncommit 2be5df8e0101b685579f1dd452059d967017148f Author: John Deng \u0026lt;john.deng@qq.com\u0026gt; Date: Sat Nov 3 07:48:46 2018 +0800 Step 3, adding Hiboot controller commit 063c72282edff85db20d4046f5801d7f5fcf4dbb Author: John Deng \u0026lt;john.deng@qq.com\u0026gt; Date: Sat Nov 3 07:45:15 2018 +0800 Step 2, adding some starters commit d9213107f6692bc22c3d79cd445567730b962477 Author: John Deng \u0026lt;john.deng@qq.com\u0026gt; Date: Sat Nov 3 07:38:59 2018 +0800 step 1: Writing the first Hiboot web application - 第一步, 快速开始Hiboot应用 编写Hiboot应用，和其它Go语言应用一样，必须有一个main包，里面包含一个main函数。\n如果你对Go语言还不熟悉，建议阅读Effective GO或中文版实效Go编程\ngit reset --hard d9213107f6692bc22c3d79cd445567730b962477 代码展示如下，这个代码已经可以执行的了，只是没有任何业务逻辑。\npackage main import ( \u0026#34;hidevops.io/hiboot/pkg/app/web\u0026#34; ) func main() { web.NewApplication().Run() } - 第二步, 添加 Starter Here we are going to add starter actuator and logging.\ngit reset --hard 063c72282edff85db20d4046f5801d7f5fcf4dbb 添加 actuator 和 logging 两个 starter\npackage main import ( \u0026#34;hidevops.io/hiboot/pkg/app/web\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/starter/actuator\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/starter/logging\u0026#34; ) func main() { web.NewApplication(). SetProperty(app.ProfilesInclude, actuator.Profile, logging.Profile). Run() } 这时候，我们来运行这段代码\ngo run main.go 输出结果如下，这时你可以看到已经映射了RESTful接口 /health, 也就是说，添加actuator starter后，即提供了健康检测接口。\n______ ____________ _____ ___ / / /__(_)__ /_______________ /_ __ /_/ /__ /__ __ \\  __ \\  __ \\  __/ _ __ / _ / _ /_/ / /_/ / /_/ / /_ Hiboot Application Framework /_/ /_/ /_/ /_.___/\\____/\\____/\\__/ https://hidevops.io/hiboot [INFO] 2018/11/01 15:51 Starting Hiboot web application hiboot-app on localhost with PID 71924 [INFO] 2018/11/01 15:51 Working directory: /Users/johnd/.gvm/pkgsets/go1.10/hidevops/src/hidevops.io/hiboot-web-app-demo [INFO] 2018/11/01 15:51 The following profiles are active: local, [actuator logging web] [INFO] 2018/11/01 15:51 Initializing Hiboot Application [INFO] 2018/11/01 15:51 Auto configure web starter [INFO] 2018/11/01 15:51 Auto configure actuator starter [INFO] 2018/11/01 15:51 Auto configure logging starter [INFO] 2018/11/01 15:51 Resolving dependencies [INFO] 2018/11/01 15:51 Injecting dependencies [INFO] 2018/11/01 15:51 Injected dependencies [INFO] 2018/11/01 15:51 Mapped \u0026#34;/health\u0026#34; onto actuator.healthController.Get() [INFO] 2018/11/01 15:51 Hiboot started on port(s) http://localhost:8080 [INFO] 2018/11/01 15:51 Started hiboot-app in 0.004189 seconds 健康检测对于生产来说非常重要，接下来我们使用httpie(当然你用curl、postman或浏览器都可以)来验证健康检测接口。\nhttp http://localhost:8080/health 输出健康状态如下：\nHTTP/1.1 200 OK Content-Length: 15 Content-Type: application/json; charset=UTF-8 Date: Thu, 01 Nov 2018 07:55:33 GMT { \u0026#34;status\u0026#34;: \u0026#34;UP\u0026#34; } - 第三步, 添加 Controller 在这个步骤，我们来增加一个RestController，名字就叫 Controller，这个结构体内嵌了at.RestController, 它的类型是interface，at.RestController在Hiboot中为注解作用，表示这是一个RestController。\n你可以编写以下代码，也可以运行以下命令直接获取。\ngit reset --hard 2be5df8e0101b685579f1dd452059d967017148f 编写代码 通过以上三步，你可以看到如何快速来编写第一个Hiboot网络应用程序\npackage main import ( \u0026#34;hidevops.io/hiboot/pkg/app/web\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/starter/actuator\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/starter/logging\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/at\u0026#34; ) // Controller Rest Controller with path / // RESTful Controller, derived from at.RestController. The context mapping of this controller is \u0026#39;/\u0026#39; by default type Controller struct { // at.RestController or at.RestController must be embedded here \tat.RestController } // Get GET / // Get method, the context mapping of this method is \u0026#39;/\u0026#39; by default // the Method name Get means that the http request method is GET func (c *Controller) Get() string { // response \treturn \u0026#34;My first Hiboot web application\u0026#34; } func main() { web.NewApplication(new(Controller)). SetProperty(app.ProfilesInclude, actuator.Profile, logging.Profile). Run() } 运行代码： go run main.go 你可以看到多了一个接口映射：/ 到 main.Controller.Get()\n______ ____________ _____ ___ / / /__(_)__ /_______________ /_ __ /_/ /__ /__ __ \\ __ \\ __ \\ __/ _ __ / _ / _ /_/ / /_/ / /_/ / /_ Hiboot Application Framework /_/ /_/ /_/ /_.___/\\____/\\____/\\__/ https://hidevops.io/hiboot  [INFO] 2018/11/01 16:07 Starting Hiboot web application hiboot-app on localhost with PID 72490 [INFO] 2018/11/01 16:07 Working directory: /Users/johnd/.gvm/pkgsets/go1.10/hidevops/src/hidevops.io/hiboot-web-app-demo [INFO] 2018/11/01 16:07 The following profiles are active: local, [actuator logging web] [INFO] 2018/11/01 16:07 Initializing Hiboot Application [INFO] 2018/11/01 16:07 Auto configure web starter [INFO] 2018/11/01 16:07 Auto configure actuator starter [INFO] 2018/11/01 16:07 Auto configure logging starter [INFO] 2018/11/01 16:07 Resolving dependencies [INFO] 2018/11/01 16:07 Injecting dependencies [INFO] 2018/11/01 16:07 Injected dependencies [INFO] 2018/11/01 16:07 Mapped \u0026#34;/health\u0026#34; onto actuator.healthController.Get() [INFO] 2018/11/01 16:07 Mapped \u0026#34;/\u0026#34; onto main.Controller.Get() [INFO] 2018/11/01 16:07 Hiboot started on port(s) http://localhost:8080 [INFO] 2018/11/01 16:07 Started hiboot-app in 0.002689 seconds 验证接口 现在我们来验证刚完成的第一个Hiboot网络应用接口：\nhttp http://localhost:8080/ 输出结果如下:\nMy first Hiboot web application 命令行应用快速入门 编写命令行应用和网络应用一样简单，也可以使用Hiboot的依赖注入和自动配置功能。\n以下代码可以在这里找到.\n// import cli starter and fmt import ( \u0026#34;fmt\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app/cli\u0026#34; ) // define the command type rootCommand struct { // embedding cli.RootCommand in each command \tcli.RootCommand // persistant flag to \tto string } func newRootCommand() *rootCommand { c := new(rootCommand) c.Use = \u0026#34;hello\u0026#34; c.Short = \u0026#34;hello command\u0026#34; c.Long = \u0026#34;run hello command for getting started\u0026#34; c.Example = ` hello -h : help hello -t John : say hello to John ` c.PersistentFlags().StringVarP(\u0026amp;c.to, \u0026#34;to\u0026#34;, \u0026#34;t\u0026#34;, \u0026#34;world\u0026#34;, \u0026#34;e.g. --to=world or -t world\u0026#34;) return c } // Run run the command func (c *rootCommand) Run(args []string) error { fmt.Printf(\u0026#34;Hello, %v\\n\u0026#34;, c.to) return nil } // main function func main() { // create new cli application and run it \tcli.NewApplication(newRootCommand). SetProperty(app.PropertyBannerDisabled, true). Run() } 运行命令行应用 dep ensure go run main.goHello, world 编译及运行 go build Let\u0026rsquo;s get help\n./hello --helprun hello command for getting started Usage: hello [flags] Flags: -h, --help help for hello -t, --to string e.g. --to=world or -t world (default \u0026#34;world\u0026#34;) Greeting to Hiboot\n./hello --to HibootHello, Hiboot 到目前为止，我们有了一定基础来编写Hiboot的网络应用和命令行应用。\n","title":"入门"},{"location":"https://hiboot.hidevops.io/cn/web-app/","text":" 主要功能  MVC架构 (Model-View-Controller). 自动配置, 事先配置好的依赖包可以被注入到任何你指定的构造函数参数中或者结构体变量 依赖注入， 使用标签 `inject:\u0026ldquo;\u0026rdquo;` 或者构造函数来实现.  MVC架构介绍 Hiboot点MVC架构采用约定俗成的原则，尽量隐藏和业务无关的代码，开发者只需遵循少数几个简单的规则即可。\n 运行时动态配置及配置值注入 注册机制 依赖注入  在入门这个章节我们了解到了简单Hiboot网络应用，现在我们以hiboot-data gorm 示例代码为例，来详细讲解任何有效的基于Hiboot来编程。\nMVC项目结构详解 下面是典型的hiboot MVC项目结构，接下来我们来对每个文件一一做详细说明。\n. ├── config │ ├── application-gorm.yml │ ├── application-local.yml │ ├── application.yml │ ├── i18n │ │ ├── en-US.ini │ │ └── zh-CN.ini │ ├── keygen.sh │ └── ssl │ ├── app.rsa │ └── app.rsa.pub ├── main.go ├── main_test.go ├── controller │ ├── user.go │ └── user_test.go ├── entity │ ├── user.go │ └── user_test.go └── service ├── user.go └── user_test.go Hiboot应用分两部分，外部配置及源代码。\n外部配置 Hiboot要做可用于生产的应用框架，在设计之初就考虑到了需要适应不同的环境。在工作目录下的config文件夹包含了不同环境下的配置文件.\nHiboot允许将配置外部化，这样你就能够在不同的环境下使用相同的代码。\n属性值可以通过`value:\u0026ldquo;\u0026rdquo;`标签直接注入到结构体中，\n下面是具体的示例，假设你开发一个使用app.name属性的struct, 如下面例子：\ntype MyService struct { AppName string `value:\u0026#34;${app.name}\u0026#34;` } 通用Application属性文件 Hiboot将从工作路径下的config文件夹中加载application.yml文件.\nconfig/application.yml application.yml定义应用项目、名称等基本信息\napp:project:examplesname:gorm-demoprofiles:include:-actuator-locale-logging-gormlogging:level:info application.yml字段说明    字段 描述 合法值 示例     app.project 项目名称 任意字符串 examples   app.name 应用名称 任意字符串 gorm-demo   app.profiles.active 当前环境配置 local,dev,test,staging,prod dev   profiles.include starter的开关功能，⚠️ 如果没有包含进来，则该starter不会被初始化，相关依赖不能被注入 starter包名 actuator, locale, logging, gorm   logging.level 定义日志级别 debug,info,warn,error,fatal info    任何以某个字符名称为后缀的配置文件，有两种情况:\n 事先定义了相关环境变量，Hiboot会认为当前应用运行在不同的环境下，如config/application-local.yml为本地开发环境，在本地电脑需要设置环境变量APP_PROFILES_ACTIVE 为 local 引用了starter，可以将starter的属性值配置到application.yml, 也可以将其配置到以starter包名为后缀的配置文件中，如本例的application-gorm.yml  config/application-local.yml server:port:8081logging:level:debug application-local.yml 字段说明    字段 描述 合法值 示例     server.port 监听端口, 通常在本地开发应用时可能有多个应用同时运行，为例防止端口冲突，可以定义不同的端口 任意数字 8081   logging.level 定义日志级别 debug,info,warn,error,fatal info    config/application-gorm.yml gorm:type:mysqlhost:mysql-${app.profiles.active:dev}port:3306database:${app.name:test}username:demopassword:fafUJCsVXf2Thj0d4n6UqNdX2PfI08fMyaNlrZhbJVVkghnZ+Zc/WCdITXflJpHZjYH5+LbLviy/6j9etPNwtdyAOXiqKI62itC6nDgp0Xlzu0qX8MwMIIAosUwaYpnflg23hRZnueKrq6SrEpkx4X+LWluDgHb2O5VfGGvHliE=charset:utf8parseTime:trueloc:Asia/Shanghaiconfig:decrypt:true application-gorm.yml字段说明    字段 描述 合法值 示例     gorm.type 数据库类型, 支持的有多种数据库 mysql,postgres,sqlite3,mssql mysql   gorm.host 数据库地址，允许使用变量 mysql-${app.profiles.active} 如在本地开发环境，设置环境变量APP_PROFILES_ACTIVE 为 local，则实际值为mysql-local，添加一条DNS的A记录即可 任何合法DNS域名或IP地址（字符串类型） mysql-${app.profiles.active}   gorm.port 数据库端口 任何有效端口 3306   gorm.database 数据库名称 字符或变量 ${app.name:test}   gorm.username 数据库用户名 合法的数据库用户名 dbuser   gorm.password 数据库密码，如果gorm.config.decrypt为true，则为crypto加密过的数据库密码 字符串 fafUJ \u0026hellip; O5VfGGvHliE=   gorm.charset 数据库字符集 utf8,ascii utf8   gorm.parseTime 是否解析时间 true,false true   gorm.loc 本地时区 参考标准时区 Asia/Shanghai   gorm.config.decrypt 是否加密密码 true,false true    main.go 和任何Go语言应用一样，Hiboot的程序入口为main包，包含两部分：引入用到的依赖包以及一个main函数。\n 为了解耦包与包之间的依赖关系，hiboot规定，依赖项采用注册，依赖注入的方式来解耦，故在main包里想要匿名引入MVC控制器hidevops.io/hiboot-data/examples/gorm/controller, 如果使用到了其它第三方自动配置包（这里一般是指starter），而代码没有显式使用的，也要匿名引人，如：hidevops.io/hiboot/pkg/starter/actuator, hidevops.io/hiboot/pkg/starter/locale, hidevops.io/hiboot/pkg/starter/logging\n main函数非常简单，只有一行代码 web.NewApplication().Run(), web包引自hidevops.io/hiboot/pkg/app/web\npackage main import ( _ \u0026#34;hidevops.io/hiboot-data/examples/gorm/controller\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app/web\u0026#34; _ \u0026#34;hidevops.io/hiboot/pkg/starter/actuator\u0026#34; _ \u0026#34;hidevops.io/hiboot/pkg/starter/locale\u0026#34; _ \u0026#34;hidevops.io/hiboot/pkg/starter/logging\u0026#34; ) func main() { web.NewApplication().Run() }  mian_test.go main函数单元测试，TestRunMain第一行代码是 go main(), 我们起一个go routine来无阻塞的测试main函数，后面代码time.Sleep(200 * time.Millisecond)做个简单延时，可以用于main函数代码覆盖测试。\npackage main import ( \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; ) func TestRunMain(t *testing.T) { go main() time.Sleep(200 * time.Millisecond) } 控制器 - controller/user.go 接下来我们来看看如何正确编写Hiboot的控制器，\n控制器 userController 内嵌 at.RestController, 指明这是个RESTful控制器。\nnewUserController为userController的构造函数，实现依赖注入，在应用启动过程中， userService service.UserService 将被自动注入到 newUserController。\n控制器是RESTful接口的入口，不同于其它Go语言网络应用框架，Hiboot控制器设计思路是尽可能的简单易用，省去路由配置代码，约定方法名即路由配置。如下userController的Post方法。\n现针对各个方法作详细说明\n   方法 描述 合法值 示例     Get GET请求 Get或以大写开头的驼峰命名法则GetById func (c *userController) GetById(id unit64)   Post POST请求 Post或以大写开头的驼峰命名法则PostUser func (c *userController) Post(request *userRequest)   Put PUT请求 Put或以大写开头的驼峰命名法则PutUser func (c *userController) Post(request *userRequest)   Delete DELETE请求 Delete或以大写开头的驼峰命名法则DeleteById func (c *userController) DeleteById(id unit64)    ⚠️ 在函数 init() 必须注册 newUserController.\npackage controller import ( \u0026#34;hidevops.io/hiboot-data/examples/gorm/entity\u0026#34; \u0026#34;hidevops.io/hiboot-data/examples/gorm/service\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app/web\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/model\u0026#34; \u0026#34;net/http\u0026#34; ) // RestController type userController struct { at.RestController userService service.UserService } func init() { app.Register(newUserController) } // newUserController inject userService automatically func newUserController(userService service.UserService) *userController { return \u0026amp;userController{ userService: userService, } } // Post POST /user func (c *userController) Post(request *entity.User) (model.Response, error) { err := c.userService.AddUser(request) response := new(model.BaseResponse) response.SetData(request) return response, err } // GetById GET /id/{id} func (c *userController) GetById(id uint64) (response model.Response, err error) { user, err := c.userService.GetUser(id) response = new(model.BaseResponse) if err != nil { response.SetCode(http.StatusNotFound) } else { response.SetData(user) } return } // GetById GET /id/{id} func (c *userController) GetAll() (response model.Response, err error) { users, err := c.userService.GetAll() response = new(model.BaseResponse) response.SetData(users) return } // DeleteById DELETE /id/{id} func (c *userController) DeleteById(id uint64) (response model.Response, err error) { err = c.userService.DeleteUser(id) response = new(model.BaseResponse) return } entity/user.go 这是业务逻辑模型。\npackage entity type User struct { Id uint64 `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` Username string `json:\u0026#34;username\u0026#34;` Password string `json:\u0026#34;password\u0026#34;` Email string `json:\u0026#34;email\u0026#34;` Age uint `json:\u0026#34;age\u0026#34;` Gender uint `json:\u0026#34;gender\u0026#34;` } func (u *User) TableName() string { return \u0026#34;user\u0026#34; } Model - service/user.go service包实现业务逻辑。\n我们定义了一个接口UserService，包含AddUser, GetUser, GetAll 和 DeleteUser方法。\nuserServiceImpl为接口UserService的具体实现。\n通过引人hiboot-data/starter/gorm，即可自动注入 repository gorm.Repository到userServiceImpl\n⚠️ 在函数 init() 必须注册 newUserService.\npackage service import ( \u0026#34;errors\u0026#34; \u0026#34;hidevops.io/hiboot-data/examples/gorm/entity\u0026#34; \u0026#34;hidevops.io/hiboot-data/starter/gorm\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/utils/idgen\u0026#34; ) type UserService interface { AddUser(user *entity.User) (err error) GetUser(id uint64) (user *entity.User, err error) GetAll() (user *[]entity.User, err error) DeleteUser(id uint64) (err error) } type userServiceImpl struct { // add UserService, it means that the instance of UserServiceImpl can be found by UserService \tUserService repository gorm.Repository } func init() { // register UserServiceImpl \tapp.Register(newUserService) } // will inject BoltRepository that configured in hidevops.io/hiboot/pkg/starter/data/bolt func newUserService(repository gorm.Repository) UserService { repository.AutoMigrate(\u0026amp;entity.User{}) return \u0026amp;userServiceImpl{ repository: repository, } } func (s *userServiceImpl) AddUser(user *entity.User) (err error) { if user == nil { return errors.New(\u0026#34;user is not allowed nil\u0026#34;) } if user.Id == 0 { user.Id, _ = idgen.Next() } err = s.repository.Create(user).Error() return } func (s *userServiceImpl) GetUser(id uint64) (user *entity.User, err error) { user = \u0026amp;entity.User{} err = s.repository.Where(\u0026#34;id = ?\u0026#34;, id).First(user).Error() return } func (s *userServiceImpl) GetAll() (users *[]entity.User, err error) { users = \u0026amp;[]entity.User{} err = s.repository.Find(users).Error() return } func (s *userServiceImpl) DeleteUser(id uint64) (err error) { err = s.repository.Where(\u0026#34;id = ?\u0026#34;, id).Delete(entity.User{}).Error() return } 运行网络应用程序 go run main.go 输出结果如下：\n______ ____________ _____ ___ / / /__(_)__ /_______________ /_ __ /_/ /__ /__ __ \\  __ \\  __ \\  __/ _ __ / _ / _ /_/ / /_/ / /_/ / /_ Hiboot Application Framework /_/ /_/ /_/ /_.___/\\____/\\____/\\__/ https://hidevops.io/hiboot [INFO] 2018/10/23 23:37 Starting Hiboot web application gorm-demo on localhost with PID 28423 [INFO] 2018/10/23 23:37 Working directory: /Users/johnd/.gvm/pkgsets/go1.10/hidevops/src/hidevops.io/hiboot-data/examples/gorm [INFO] 2018/10/23 23:37 The following profiles are active: local, [actuator locale logging gorm] [INFO] 2018/10/23 23:37 Auto configure gorm starter [INFO] 2018/10/23 23:37 Auto configure locale starter [INFO] 2018/10/23 23:37 Auto configure logging starter [INFO] 2018/10/23 23:37 The dependency graph resolved successfully [INFO] 2018/10/23 23:37 connected to dataSource demo@mysql-local:3306/gorm_demo [DBUG] 2018/10/23 23:36 GET: /health -\u0026gt; github.com/hidevops\tio/hiboot-data/vendor/hidevops.io/hiboot/pkg/starter/actuator/controller/healthController.Get() and 2 more [DBUG] 2018/10/23 23:36 DELETE: /user/id/{id} -\u0026gt; hidevops.io/hiboot-data/examples/gorm/controller/userController.DeleteById() and 2 more [DBUG] 2018/10/23 23:36 GET: /user/id/{id} -\u0026gt; hidevops.io/hiboot-data/examples/gorm/controller/userController.GetById() and 2 more [DBUG] 2018/10/23 23:36 GET: /user/all -\u0026gt; hidevops.io/hiboot-data/examples/gorm/controller/userController.GetAll() and 2 more [DBUG] 2018/10/23 23:36 POST: /user -\u0026gt; hidevops.io/hiboot-data/examples/gorm/controller/userController.Post() and 2 more Now listening on: http://localhost:8080 Application started. Press CMD+C to shut down. 请求接口 让我们用httpie来请求接口\nhttp GET localhost:8080/user/all?lang=zh-CN 输出结果如下：\nHTTP/1.1 200 OK Content-Length: 307 Content-Type: application/json; charset=UTF-8 Date: Tue, 23 Oct 2018 15:38:41 GMT Set-Cookie: app.language=zh-CN; Path=/; Expires=Tue, 23 Oct 2018 17:38:41 GMT; Max-Age=7200; HttpOnly { \u0026#34;code\u0026#34;: 200, \u0026#34;data\u0026#34;: [ { \u0026#34;age\u0026#34;: 18, \u0026#34;email\u0026#34;: \u0026#34;john.doe@gmail.com\u0026#34;, \u0026#34;gender\u0026#34;: 0, \u0026#34;id\u0026#34;: 209536579658580081, \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;poi321\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;johnd\u0026#34; }, { \u0026#34;age\u0026#34;: 25, \u0026#34;email\u0026#34;: \u0026#34;mike.phil@gmail.com\u0026#34;, \u0026#34;gender\u0026#34;: 0, \u0026#34;id\u0026#34;: 209536656246571121, \u0026#34;name\u0026#34;: \u0026#34;Mike Phil\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;iutg039\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;mikep\u0026#34; } ], \u0026#34;message\u0026#34;: \u0026#34;成功\u0026#34; } 单元测试 我说过，Hiboot从一开始就考虑到必须能用于生产环境，我们非常在意代码质量。你可以看我们集成了CI流程，代码必须通过严格的测试之后才会合并到主分支。这是Hiboot实时的代码测试覆盖率 . 那么，我们是怎样来做单元测试的呢?\n首先，让我们来看main.go下面最简单的单元测试，\nmian_test.go 为了简单起见, 我们用一个go routine 来跑main函数的测试 go main() 在这个单元测试用例 TestRunMain。当然这不是真正意义上的测试， 因为里面并没有assert语句，我们并不知道测试结果。\npackage main import ( \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; ) func TestRunMain(t *testing.T) { go main() time.Sleep(200 * time.Millisecond) } 模拟测试 - controller/user_test.go 我们想测试 userController, 但是userController 依赖了 userSerivce，而userSerivce 又会连接真正的数据库，可是我们要做自动化测试，我们要做持续集成怎么办？当然我们可以使用模拟测试法。\n我们使用模拟测试代码生成工具Mockery 来生成部分测试代码，以减轻我们写代码的负担。\n首先，我们来安装Mockery\ngo get github.com/vektra/mockery/.../ 然后，为接口UserService生成模拟测试代码，当然你得到相应的文件夹下面去生成代码，你也可以指定文件夹，具体方法可以看Mockery的帮助文档（运行 mockery -h 查看）\n# go to the directory where the UserService is. cd $GOPATH/src/hidevops.io/hiboot-data/examples/gorm/service # generate mocks for the interface UserService mockery -name UserService 接下来，你将会在项目下面（$GOPATH/src/hidevops.io/hiboot-data/examples/gorm/service.)看到生成好的模拟测试代码。\n// Code generated by mockery v1.0.0. DO NOT EDIT.  package mocks import entity \u0026#34;hidevops.io/hiboot-data/examples/gorm/entity\u0026#34; import mock \u0026#34;github.com/stretchr/testify/mock\u0026#34; // UserService is an autogenerated mock type for the UserService type type UserService struct { mock.Mock } // AddUser provides a mock function with given fields: user func (_m *UserService) AddUser(user *entity.User) error { ret := _m.Called(user) var r0 error if rf, ok := ret.Get(0).(func(*entity.User) error); ok { r0 = rf(user) } else { r0 = ret.Error(0) } return r0 } // DeleteUser provides a mock function with given fields: id func (_m *UserService) DeleteUser(id uint64) error { ret := _m.Called(id) var r0 error if rf, ok := ret.Get(0).(func(uint64) error); ok { r0 = rf(id) } else { r0 = ret.Error(0) } return r0 } // GetAll provides a mock function with given fields: func (_m *UserService) GetAll() (*[]entity.User, error) { ret := _m.Called() var r0 *[]entity.User if rf, ok := ret.Get(0).(func() *[]entity.User); ok { r0 = rf() } else { if ret.Get(0) != nil { r0 = ret.Get(0).(*[]entity.User) } } var r1 error if rf, ok := ret.Get(1).(func() error); ok { r1 = rf() } else { r1 = ret.Error(1) } return r0, r1 } // GetUser provides a mock function with given fields: id func (_m *UserService) GetUser(id uint64) (*entity.User, error) { ret := _m.Called(id) var r0 *entity.User if rf, ok := ret.Get(0).(func(uint64) *entity.User); ok { r0 = rf(id) } else { if ret.Get(0) != nil { r0 = ret.Get(0).(*entity.User) } } var r1 error if rf, ok := ret.Get(1).(func(uint64) error); ok { r1 = rf(id) } else { r1 = ret.Error(1) } return r0, r1 } Writing the unit test cases 接着我们就要来写相关的测试用例了，下面我们测试了POST, GET, DELETE几个方法，而其中并没有去连接数据库，但是能测试到userController的业务逻辑。\npackage controller import ( \u0026#34;hidevops.io/hiboot-data/examples/gorm/entity\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app/web\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/log\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/utils/idgen\u0026#34; \u0026#34;github.com/stretchr/testify/assert\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;hidevops.io/hiboot-data/examples/gorm/service/mocks\u0026#34; \u0026#34;errors\u0026#34; ) func init() { log.SetLevel(log.DebugLevel) } func TestCrdRequest(t *testing.T) { mockUserService := new(mocks.UserService) userController := newUserController(mockUserService) testApp := web.RunTestApplication(t, userController) id, err := idgen.Next() assert.Equal(t, nil, err) testUser := \u0026amp;entity.User{ Id: id, Name: \u0026#34;Bill Gates\u0026#34;, Username: \u0026#34;billg\u0026#34;, Password: \u0026#34;3948tdaD\u0026#34;, Email: \u0026#34;bill.gates@microsoft.com\u0026#34;, Age: 60, Gender: 1, } // first, call mocks.UserService.AddUser \tmockUserService.On(\u0026#34;AddUser\u0026#34;, testUser).Return(nil) // then run the test that will call UserService.AddUser \tt.Run(\u0026#34;should add user with POST request\u0026#34;, func(t *testing.T) { // First, let\u0026#39;s Post User \ttestApp.Post(\u0026#34;/user\u0026#34;). WithJSON(testUser). Expect().Status(http.StatusOK) }) mockUserService.On(\u0026#34;GetUser\u0026#34;, id).Return(testUser, nil) t.Run(\u0026#34;should get user with GET request\u0026#34;, func(t *testing.T) { // Then Get User \t// e.g. GET /user/id/123456 \ttestApp.Get(\u0026#34;/user/id/{id}\u0026#34;). WithPath(\u0026#34;id\u0026#34;, id). Expect().Status(http.StatusOK) }) mockUserService.On(\u0026#34;GetAll\u0026#34;).Return(\u0026amp;[]entity.User{*testUser}, nil) t.Run(\u0026#34;should get user with GET request\u0026#34;, func(t *testing.T) { // Then Get User \t// e.g. GET /user/id/123456 \ttestApp.Get(\u0026#34;/user/all\u0026#34;). Expect().Status(http.StatusOK) }) // assert that the expectations were met \tmockUserService.AssertExpectations(t) unknownId, err := idgen.Next() assert.Equal(t, nil, err) mockUserService.On(\u0026#34;GetUser\u0026#34;, unknownId).Return((*entity.User)(nil), errors.New(\u0026#34;not found\u0026#34;)) t.Run(\u0026#34;should return 404 if trying to find a record that does not exist\u0026#34;, func(t *testing.T) { // Then Get User \ttestApp.Get(\u0026#34;/user/id/{id}\u0026#34;). WithPath(\u0026#34;id\u0026#34;, unknownId). Expect().Status(http.StatusNotFound) }) // assert that the expectations were met \tmockUserService.AssertExpectations(t) mockUserService.On(\u0026#34;DeleteUser\u0026#34;, id).Return(nil) t.Run(\u0026#34;should delete the record with DELETE request\u0026#34;, func(t *testing.T) { // Finally Delete User \ttestApp.Delete(\u0026#34;/user/id/{id}\u0026#34;). WithPath(\u0026#34;id\u0026#34;, id). Expect().Status(http.StatusOK) }) } 最后，我们来运行测试用例，\n","title":"网络应用"},{"location":"https://hiboot.hidevops.io/cn/cli-app/","text":" 关于 Hiboot命令行应用是在cobra的基础上构建的。得益于Hiboot提供的依赖注入和自动配置功能，开发者将会更高效的开发出命令行应用。\n功能列表  使用依赖注入来注入子命令 子命令处理方法  项目结构 . ├── cmd │ ├── bar.go │ ├── foo.go │ ├── root.go │ ├── root_test.go │ └── second.go ├── config │ ├── autoconfigure.go │ └── autoconfigure_test.go ├── main.go ├── main_test.go └── model ├── foo.go └── foo_test.go 就如Hiboot网络应用，Hiboot命令行应用的宗旨是让开发更简单、更容易。\npackage main import ( \u0026#34;hidevops.io/hiboot/examples/cli/advanced/cmd\u0026#34; \u0026#34;hidevops.io/hiboot/examples/cli/advanced/config\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app/cli\u0026#34; ) func main() { // create new cli application and run it \tcli.NewApplication(cmd.NewRootCommand). SetProperty(app.ProfilesInclude, config.Profile). Run() } 根命令 每个命令行应用都会有唯一的根命令。通过在根命令的结构体内嵌cli.RootCommand来标识。\n命令的处理方法为Run(args []string) error\npackage cmd import ( \u0026#34;hidevops.io/hiboot/pkg/app/cli\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/log\u0026#34; ) // HelloCommand is the root command type HelloCommand struct { cli.RootCommand profile string timeout int } // HelloCommand the root command func NewHelloCommand(second *secondCommand) *HelloCommand { c := new(RootCommand) c.Use = \u0026#34;hello\u0026#34; c.Short = \u0026#34;hello command\u0026#34; c.Long = \u0026#34;Run hello command\u0026#34; c.ValidArgs = []string{\u0026#34;baz\u0026#34;} pf := c.PersistentFlags() pf.StringVarP(\u0026amp;c.profile, \u0026#34;profile\u0026#34;, \u0026#34;p\u0026#34;, \u0026#34;dev\u0026#34;, \u0026#34;e.g. --profile=test\u0026#34;) pf.IntVarP(\u0026amp;c.timeout, \u0026#34;timeout\u0026#34;, \u0026#34;t\u0026#34;, 1, \u0026#34;e.g. --timeout=1\u0026#34;) c.Add(second) return c } // Run root command handler func (c *HelloCommand) Run(args []string) error { log.Infof(\u0026#34;handle first command: profile=%v, timeout=%v\u0026#34;, c.profile, c.timeout) return nil } 子命令 所有的子命令在使用app.Register()注册后即可注入到任何上级命令。这里需要提醒的是注意依赖关系，不要循环依赖。\n子命令通过在子命令的结构体内嵌cli.SubCommand来标识。\npackage cmd import ( \u0026#34;hidevops.io/hiboot/pkg/app\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app/cli\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/log\u0026#34; ) type secondCommand struct { cli.SubCommand } func init() { app.Register(newSecondCommand) } func newSecondCommand(foo *fooCommand, bar *barCommand) *secondCommand { c := new(secondCommand) c.Use = \u0026#34;second\u0026#34; c.Short = \u0026#34;second command\u0026#34; c.Long = \u0026#34;Run second command\u0026#34; c.Add(foo, bar) return c } func (c *secondCommand) Run(args []string) error { log.Info(\u0026#34;handle second command\u0026#34;) return nil }","title":"命令行应用"},{"location":"https://hiboot.hidevops.io/cn/inversion-of-control/","text":" 简述 控制反转是一种设计思想，适用于任何编程语言。包含了服务定位器(Service Locator)，事件(Events)，委托(Delegates)和依赖注入(Dependency Injection)。到目前为止，Hiboot实现了依赖注入部分，所以我们主要来讲解依赖注入部分。如何编写出松耦合，易维护的应用是Hiboot框架的设计初衷。根据这个设计思想，我们不应该在结构体，函数或方法中静态的配置其依赖，而应该将依赖配置在外部。\n依赖注入设计模式允许我们解除应用组件间的强依赖关系，是应用程序松耦合，可扩展和可维护。\nGo语言的一个结构体A依赖于另外一个结构体B，如果A用到了B的实例，我们说A依赖B。例如，userController 依赖 userService.\ntype userController struct { at.RestController userService service.UserService } func newUserController(userService service.UserService) *userController { return \u0026amp;userController{ userService: userService, } } 理想的状况是一个Go语言的结构体应该尽量独立以其它结构体。这样可增加结构体的复用性以及可测试性。\n依赖注入 和前面章节一样，我们还是通过示例来说明Hiboot的依赖注入是如何工作的。\n⚠️ 注意：\n 如果你想要注入当是一个实例，依赖注入定义的相关字段或参数，其数据类型必须是结构体指针或interface{}. 如果你尝试定义其它类型将不会成功。 依赖注入实例的来源主要有两个，一个是通过app.Register()注册结构体构造器，另外一个是通过自动配置的方法注册。  正例：\ntype Foo struct { } func newFoo() *Foo { return \u0026amp;Foo{} } type Bar struct { foo *Foo } func newBar(foo *Foo) *Bar { return \u0026amp;Bar{ foo: foo, } } func init() { app.Register(newFoo, newBar) } 反例：\n在这个反例中，foo不是一个指针，将不会被注入。\ntype Foo struct { } func newFoo() *Foo { return \u0026amp;Foo{} } type Bar struct { foo Foo } func newBar(foo Foo) *Bar { return \u0026amp;Bar{ foo: foo, } } func init() { app.Register(newFoo, newBar) } 构造器注入 Hiboot建议使用构造器来注入，因为构造器注入能够保证注入的组件不可变，并且确保需要的依赖不为空。并且，构造器注入的依赖总数能够保证组件完全初始化的状态。\n 使用构造器注入的字段可以是私有的，不像字段注入，Go语言要求使用标签时，字段必须大写开头，这样就暴露了该字段，这就有被更改的风险。 通过构造器注入Hiboot可以保证依赖不会为空。\npackage main import ( \u0026#34;hidevops.io/hiboot/pkg/app/web\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/model\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/starter/jwt\u0026#34; \u0026#34;time\u0026#34; ) // This example shows that jwtToken is injected through the constructor, // once you imported \u0026#34;hidevops.io/hiboot/pkg/starter/jwt\u0026#34;, // jwtToken jwt.Token will be injectable. func main() { // the web application entry \tweb.NewApplication().Run() } // PATH: /login type loginController struct { at.RestController token jwt.Token } type userRequest struct { // embedded field model.RequestBody mark that userRequest is request body \tmodel.RequestBody Username string `json:\u0026#34;username\u0026#34; validate:\u0026#34;required\u0026#34;` Password string `json:\u0026#34;password\u0026#34; validate:\u0026#34;required\u0026#34;` } func init() { // Register Rest Controller through constructor newLoginController \tapp.Register(newLoginController) } // newLoginController inject jwtToken through the argument jwtToken jwt.Token on constructor // the dependency jwtToken is auto configured in jwt starter, see https://hidevops.io/hiboot/pkg/starter/jwt func newLoginController(token jwt.Token) *loginController { return \u0026amp;loginController{ token: token, } } // Post / // The first word of method is the http method POST, the rest is the context mapping func (c *loginController) Post(request *userRequest) (response model.Response, err error) { jwtToken, _ := c.token.Generate(jwt.Map{ \u0026#34;username\u0026#34;: request.Username, \u0026#34;password\u0026#34;: request.Password, }, 30, time.Minute) response = new(model.BaseResponse) response.SetData(jwtToken) return }  字段注入 我们来将上面这段代码做个些的改动（⚠️ 我们将 token 改成了 Token， 这是因为Go语言定义了标签的字段必须是大写字母开头的，也就是对外公开），不用构造器也是可以注入的。Hiboot通过标签注入实例到字段 Token 中, 尽管使用的效果和构造器差不多，但是我们还是建议使用构造器来注入，原因在上面有说明。\npackage main import ( \u0026#34;hidevops.io/hiboot/pkg/app/web\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/model\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/starter/jwt\u0026#34; \u0026#34;time\u0026#34; ) // This example shows that jwtToken is injected through the constructor, // once you imported \u0026#34;hidevops.io/hiboot/pkg/starter/jwt\u0026#34;, // jwtToken jwt.Token will be injectable. func main() { // the web application entry \tweb.NewApplication().Run() } // PATH: /login type loginController struct { at.RestController // Inject Token by tag `inject:\u0026#34;\u0026#34;` \tToken jwt.Token `inject:\u0026#34;\u0026#34;` } type userRequest struct { // embedded field model.RequestBody mark that userRequest is request body \tmodel.RequestBody Username string `json:\u0026#34;username\u0026#34; validate:\u0026#34;required\u0026#34;` Password string `json:\u0026#34;password\u0026#34; validate:\u0026#34;required\u0026#34;` } func init() { // Register Rest Controller through constructor newLoginController \tapp.Register(newLoginController) } // newLoginController inject jwtToken through the argument jwtToken jwt.Token on constructor // the dependency jwtToken is auto configured in jwt starter, see https://hidevops.io/hiboot/pkg/starter/jwt func newLoginController() *loginController { return \u0026amp;loginController{} } // Post / // The first word of method is the http method POST, the rest is the context mapping func (c *loginController) Post(request *userRequest) (response model.Response, err error) { // c.Token 是通过 inject 标签注入的，可以直接使用 \tjwtToken, _ := c.Token.Generate(jwt.Map{ \u0026#34;username\u0026#34;: request.Username, \u0026#34;password\u0026#34;: request.Password, }, 30, time.Minute) response = new(model.BaseResponse) response.SetData(jwtToken) return } Hiboot字段注入是通过标签`inject:\u0026ldquo;\u0026rdquo;`来实现到。当在某个字段标注了`inject:\u0026ldquo;\u0026rdquo;`，Hiboot会尝试找到相应的实例并且注入到字段中，如果你尝试让Hiboot注入一个不存在的依赖项，Hiboot会在应用启动时报告错误。\n如果需要注入的依赖有多个实现，则可以指定名称，比如`inject:\u0026ldquo;buzService\u0026rdquo;`， Hiboot会先寻找标签当名字，如果该实例不存在则会寻找是否有以该字段名命名当实例，最后才寻找以该字段数据类型命名当实例。\ntype BxzService interface { GetNickname() string } type bazService struct { Name string nickname string } func (s *bazService) GetNickname() string { return s.nickname } type buzService struct { Name string nickname string } func (s *buzService) GetNickname() string { return s.nickname } type bxzServiceImpl struct { BxzService Name string nickname string } func (s *bxzServiceImpl) GetNickname() string { return s.nickname } type dependencyInjectionTestService struct { BxzSvc BxzService `inject:\u0026#34;\u0026#34;` BazService BxzService `inject:\u0026#34;\u0026#34;` BuzService BxzService `inject:\u0026#34;\u0026#34;` BozService BxzService `inject:\u0026#34;buzService\u0026#34;` name string } 方法注入 方法注入是Hiboot的一大特点，下面是Hiboot starter jwt的实际代码。在方法Middleware()中依赖了Token，Hiboot会自动将Token实例注入到Middleware()方法的参数jwtToken Token。 关于Hiboot starter会在后面章节详细讲解。\n// Package jwt provides the hiboot starter for injectable jwt dependency package jwt import ( \u0026#34;github.com/dgrijalva/jwt-go\u0026#34; \u0026#34;hidevops.io/hiboot/pkg/app\u0026#34; mw \u0026#34;github.com/iris-contrib/middleware/jwt\u0026#34; ) type configuration struct { app.Configuration Properties Properties `mapstructure:\u0026#34;jwt\u0026#34;` middleware *Middleware token Token } func init() { app.Register(newConfiguration) } func newConfiguration() *configuration { return \u0026amp;configuration{} } // Middleware is the jwt handler func (c *configuration) Middleware(jwtToken Token) *Middleware { return NewJwtMiddleware(mw.Config{ ValidationKeyGetter: func(token *jwt.Token) (interface{}, error) { //log.Debug(token) \treturn jwtToken.VerifyKey(), nil }, // When set, the middleware verifies that tokens are signed with the specific signing algorithm \t// If the signing method is not constant the ValidationKeyGetter callback can be used to implement additional checks \t// Important to avoid security issues described here: https://auth0.com/blog/2015/03/31/critical-vulnerabilities-in-json-web-token-libraries/ \tSigningMethod: jwt.SigningMethodRS256, }) } // Token func (c *configuration) Token() Token { t := new(jwtToken) t.Initialize(\u0026amp;c.Properties) return t }","title":"控制反转"},{"location":"https://hiboot.hidevops.io/cn/auto-configure/","text":" 自动配置 Starter Hiboot auto-configuration attempts to automatically configure your Hiboot application based on the pkg dependencies that you have added. For example, if bolt is imported in you main.go, and you have not manually configured any database connection, then Hiboot auto-configures an database bolt for any service to inject.\nYou need to opt-in to auto-configuration by embedding app.Configuration in your configuration and calling the app.Register() function inside the init() function of your configuration pkg.\nFor more details, see https://godoc.org/hidevops.io/hiboot/pkg/starter\n创建你自己的 Starter A full Hiboot starter for a library may contain the following structs: autoconfigure - object that handle the auto-configuration code. properties - object that contains properties which will be injected configurable default values or user specified values If you work in a company that develops shared go packages, or if you work on an open-source or commercial project, you might want to develop your own auto-configured starter. starter can be implemented in external packages and can be imported by any go applications.\nUnderstanding Auto-configured Starter\nUnder the hood, auto-configuration is implemented with standard struct. Additional embedded field app.Configuration. AutoConfiguration used to constrain when the auto-configuration should apply. Usually, auto-configuration struct use after:\u0026quot;fooConfiguration\u0026quot; or missing:\u0026quot;fooConfiguration\u0026quot; tags. This ensures that auto-configuration applies only when relevant configuration are found and when you have not declared your own configuration.\n代码示例 This example shows the guide to make customized auto configuration for more details, see https://hidevops.io/hiboot-data/blob/master/starter/bolt/autoconfigure.go\npackage bolt import ( \u0026#34;hidevops.io/hiboot/pkg/app\u0026#34; \u0026#34;os\u0026#34; ) // properties type properties struct { Database string `json:\u0026#34;database\u0026#34; default:\u0026#34;hiboot.db\u0026#34;` Mode os.FileMode `json:\u0026#34;mode\u0026#34; default:\u0026#34;0600\u0026#34;` Timeout int64 `json:\u0026#34;timeout\u0026#34; default:\u0026#34;2\u0026#34;` } // declare boltConfiguration type boltConfiguration struct { app.Configuration // the properties member name must be Bolt if the mapstructure is bolt, \t// so that the reference can be parsed \tBoltProperties properties `mapstructure:\u0026#34;bolt\u0026#34;` } // BoltRepository type BoltRepository struct { } func init() { // register newBoltConfiguration as AutoConfiguration \tapp.Register(newBoltConfiguration) } // boltConfiguration constructor func newBoltConfiguration() *boltConfiguration { return \u0026amp;boltConfiguration{} } func (c *boltConfiguration) BoltRepository() *BoltRepository { repo := \u0026amp;BoltRepository{} // config repo according to c.BoltProperties  return repo }","title":"自动配置"},{"location":"https://hiboot.hidevops.io/cn/tags/auto-configuration/","text":"","title":"auto-configuration"},{"location":"https://hiboot.hidevops.io/cn/tags/go/","text":"","title":"go"},{"location":"https://hiboot.hidevops.io/cn/tags/starter/","text":"","title":"starter"},{"location":"https://hiboot.hidevops.io/cn/tags/","text":"","title":"Tags"},{"location":"https://hiboot.hidevops.io/cn/tags/application/","text":"","title":"application"},{"location":"https://hiboot.hidevops.io/cn/tags/cli/","text":"","title":"cli"},{"location":"https://hiboot.hidevops.io/cn/tags/web/","text":"","title":"web"},{"location":"https://hiboot.hidevops.io/cn/tags/index/","text":"","title":"Index"},{"location":"https://hiboot.hidevops.io/cn/topics/","text":"","title":"Topics"},{"location":"https://hiboot.hidevops.io/cn/search/","text":"","title":"搜索结果"}]